{"version":3,"sources":["../../src/server/models/appointment.js"],"names":["AppointmentSchema","Schema","startDate","type","Date","required","endDate","client","ObjectId","ref","professional","location","String","createdAt","default","now","statics","get","id","findById","populate","exec","then","Appointment","list","skip","limit","find","sort","model"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAMA,oBAAoB,IAAI,mBAASC,MAAb,CAAoB;AAC1CC,eAAU;AACNC,cAAMC,IADA;AAENC,kBAAU;AAFJ,KADgC;AAK1CC,aAAQ;AACJH,cAAMC,IADF;AAEJC,kBAAU;AAFN,KALkC;AAS1CE,YAAQ;AACJJ,cAAM,mBAASF,MAAT,CAAgBO,QADlB;AAEJC,aAAK;AAFD,KATkC;AAa1CC,kBAAc;AACVP,cAAM,mBAASF,MAAT,CAAgBO,QADZ;AAEVC,aAAK;AAFK,KAb4B;AAiB1CE,cAAU;AACNR,cAAMS;AADA,KAjBgC;AAoB1CC,eAAW;AACPV,cAAMC,IADC;AAEPU,iBAASV,KAAKW;AAFP;AApB+B,CAApB,CAA1B;;AA0BA;;;AAGAf,kBAAkBgB,OAAlB,GAA4B;AACxB;;;;;AAKAC,OANwB,eAMpBC,EANoB,EAMhB;AACJ,eAAO,KAAKC,QAAL,CAAcD,EAAd,EACNE,QADM,CACG,qBADH,EAENC,IAFM,GAGNC,IAHM,CAGD,UAACC,WAAD,EAAiB;AACnB,gBAAIA,WAAJ,EAAiB;AACb,uBAAOA,WAAP;AACH;AACD,mBAAO,IAAP;AACA;AACA;AACH,SAVM,CAAP;AAWH,KAlBuB;;;AAoBxB;;;;;;AAMAC,QA1BwB,kBA0BY;AAAA,uFAAJ,EAAI;AAAA,6BAA7BC,IAA6B;AAAA,YAA7BA,IAA6B,6BAAtB,CAAsB;AAAA,8BAAnBC,KAAmB;AAAA,YAAnBA,KAAmB,8BAAX,EAAW;;AAChC,eAAO,KAAKC,IAAL,GACNC,IADM,CACD,EAAEf,WAAW,CAAC,CAAd,EADC,EAENY,IAFM,CAEDA,IAFC,EAGNC,KAHM,CAGAA,KAHA,EAINL,IAJM,EAAP;AAKH;AAhCuB,CAA5B;;kBAoCe,mBAASQ,KAAT,CAAe,aAAf,EAA8B7B,iBAA9B,C","file":"appointment.js","sourcesContent":["import Promise from 'bluebird';\r\nimport mongoose from 'mongoose';\r\nimport httpStatus from 'http-status';\r\nimport APIError from '../lib/APIError';\r\nimport validator from 'validator';\r\nimport bcrypt from 'bcrypt-nodejs';\r\n\r\nconst AppointmentSchema = new mongoose.Schema({\r\n    startDate:{\r\n        type: Date,\r\n        required: true\r\n    },\r\n    endDate:{\r\n        type: Date,\r\n        required: true\r\n    },\r\n    client: {\r\n        type: mongoose.Schema.ObjectId,\r\n        ref: 'Client'\r\n    },\r\n    professional: {\r\n        type: mongoose.Schema.ObjectId,\r\n        ref: 'Professional'\r\n    },\r\n    location: {\r\n        type: String\r\n    },\r\n    createdAt: {\r\n        type: Date,\r\n        default: Date.now\r\n    }\r\n});\r\n\r\n/**\r\n* Statics\r\n*/\r\nAppointmentSchema.statics = {\r\n    /**\r\n    * Get Appointment\r\n    * @param {ObjectId} id - The objectId of Appointment.\r\n    * @returns {Promise<Appointment, APIError>}\r\n    */\r\n    get(id) {\r\n        return this.findById(id)\r\n        .populate('professional client')\r\n        .exec()\r\n        .then((Appointment) => {\r\n            if (Appointment) {\r\n                return Appointment;\r\n            }\r\n            return null;\r\n            // const err = new APIError('No such Appointment exists!', httpStatus.NOT_FOUND);\r\n            // return Promise.reject(err);\r\n        });\r\n    },\r\n\r\n    /**\r\n    * List Appointments in descending order of 'createdAt' timestamp.\r\n    * @param {number} skip - Number of Appointments to be skipped.\r\n    * @param {number} limit - Limit number of Appointments to be returned.\r\n    * @returns {Promise<Appointment[]>}\r\n    */\r\n    list({ skip = 0, limit = 50 } = {}) {\r\n        return this.find()\r\n        .sort({ createdAt: -1 })\r\n        .skip(skip)\r\n        .limit(limit)\r\n        .exec();\r\n    }\r\n};\r\n\r\n\r\nexport default mongoose.model('Appointment', AppointmentSchema);\r\n"]}