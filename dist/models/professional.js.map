{"version":3,"sources":["../../src/server/models/professional.js"],"names":["ProfessionalSchema","Schema","email","type","String","required","validate","isEmail","unique","firstname","lastname","title","imageUrl","organization","ObjectId","ref","clients","status","Boolean","createdAt","Date","default","now","statics","get","id","findById","populate","exec","then","Professional","getByEmail","findOne","list","skip","limit","find","sort","model"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAMA,qBAAqB,IAAI,mBAASC,MAAb,CAAoB;AAC3CC,WAAM;AACFC,cAAMC,MADJ;AAEFC,kBAAU,IAFR;AAGFC,kBAAU,CAAE,oBAAUC,OAAZ,EAAqB,eAArB,CAHR;AAIFC,gBAAQ;AAJN,KADqC;AAO3CC,eAAW;AACPN,cAAMC;AADC,KAPgC;AAU3CM,cAAU;AACNP,cAAMC;AADA,KAViC;AAa3CO,WAAO;AACHR,cAAMC;AADH,KAboC;AAgB3CQ,cAAU;AACNT,cAAMC;AADA,KAhBiC;AAmB3CS,kBAAc;AACVV,cAAM,mBAASF,MAAT,CAAgBa,QADZ;AAEVC,aAAK;AAFK,KAnB6B;AAuB3CC,aAAQ,CAAC,EAACb,MAAK,mBAASF,MAAT,CAAgBa,QAAtB,EAA+BC,KAAI,QAAnC,EAAD,CAvBmC;AAwB3C;AACAE,YAAQ;AACJd,cAAMe;AADF,KAzBmC;AA4B3CC,eAAW;AACPhB,cAAMiB,IADC;AAEPC,iBAASD,KAAKE;AAFP;AA5BgC,CAApB,CAA3B;;AAkCA;;;AAGAtB,mBAAmBuB,OAAnB,GAA6B;AACzB;;;;;AAKAC,OANyB,eAMrBC,EANqB,EAMjB;AACJ,eAAO,KAAKC,QAAL,CAAcD,EAAd,EACNE,QADM,CACG,sBADH,EAENC,IAFM,GAGNC,IAHM,CAGD,UAACC,YAAD,EAAkB;AACpB,gBAAIA,YAAJ,EAAkB;AACd,uBAAOA,YAAP;AACH;AACD,mBAAO,IAAP;AACA;AACA;AACH,SAVM,CAAP;AAWH,KAlBwB;;AAmBzB;;;;;AAKAC,cAxByB,sBAwBd7B,KAxBc,EAwBP;AACd,eAAO,KAAK8B,OAAL,CAAa,EAAC9B,OAAMA,KAAP,EAAb,EACNyB,QADM,CACG,SADH,EAENC,IAFM,GAECC,IAFD,CAEM,UAACC,YAAD,EAAkB;AAC3B,gBAAIA,YAAJ,EAAkB;AACd,uBAAOA,YAAP;AACH;AACD,mBAAO,IAAP;AACA;AACA;AACH,SATM,CAAP;AAUH,KAnCwB;;;AAqCzB;;;;;;AAMAG,QA3CyB,kBA2CW;AAAA,uFAAJ,EAAI;AAAA,6BAA7BC,IAA6B;AAAA,YAA7BA,IAA6B,6BAAtB,CAAsB;AAAA,8BAAnBC,KAAmB;AAAA,YAAnBA,KAAmB,8BAAX,EAAW;;AAChC,eAAO,KAAKC,IAAL,GACNC,IADM,CACD,EAAElB,WAAW,CAAC,CAAd,EADC,EAENe,IAFM,CAEDA,IAFC,EAGNC,KAHM,CAGAA,KAHA,EAINP,IAJM,EAAP;AAKH;AAjDwB,CAA7B;;kBAqDe,mBAASU,KAAT,CAAe,cAAf,EAA+BtC,kBAA/B,C","file":"professional.js","sourcesContent":["import Promise from 'bluebird';\r\nimport mongoose from 'mongoose';\r\nimport httpStatus from 'http-status';\r\nimport APIError from '../lib/APIError';\r\nimport validator from 'validator';\r\nimport bcrypt from 'bcrypt-nodejs';\r\n\r\nconst ProfessionalSchema = new mongoose.Schema({\r\n    email:{\r\n        type: String,\r\n        required: true,\r\n        validate: [ validator.isEmail, 'invalid email' ],\r\n        unique: true\r\n    },\r\n    firstname: {\r\n        type: String,\r\n    },\r\n    lastname: {\r\n        type: String,\r\n    },\r\n    title: {\r\n        type: String,\r\n    },\r\n    imageUrl: {\r\n        type: String,\r\n    },\r\n    organization: {\r\n        type: mongoose.Schema.ObjectId,\r\n        ref: 'Organization'\r\n    },\r\n    clients:[{type:mongoose.Schema.ObjectId,ref:'Client'}],\r\n    //1 = active, 0 = disabled or disactive\r\n    status: {\r\n        type: Boolean\r\n    },\r\n    createdAt: {\r\n        type: Date,\r\n        default: Date.now\r\n    }\r\n});\r\n\r\n/**\r\n* Statics\r\n*/\r\nProfessionalSchema.statics = {\r\n    /**\r\n    * Get Professional\r\n    * @param {ObjectId} email - The email of Professional.\r\n    * @returns {Promise<Professional, APIError>}\r\n    */\r\n    get(id) {\r\n        return this.findById(id)\r\n        .populate('clients organization')\r\n        .exec()\r\n        .then((Professional) => {\r\n            if (Professional) {\r\n                return Professional;\r\n            }\r\n            return null;\r\n            // const err = new APIError('No such Professional exists!', httpStatus.NOT_FOUND);\r\n            // return Promise.reject(err);\r\n        });\r\n    },\r\n    /**\r\n    * Get Professional by Email\r\n    * @param {string} email - The email of Professional.\r\n    * @returns {Promise<Professional, APIError>}\r\n    */\r\n    getByEmail(email) {\r\n        return this.findOne({email:email})\r\n        .populate('clients')\r\n        .exec().then((Professional) => {\r\n            if (Professional) {\r\n                return Professional;\r\n            }\r\n            return null;\r\n            // const err = new APIError('No such Professional exists!', httpStatus.NOT_FOUND);\r\n            // return Promise.reject(err);\r\n        });\r\n    },\r\n\r\n    /**\r\n    * List Professionals in descending order of 'createdAt' timestamp.\r\n    * @param {number} skip - Number of Professionals to be skipped.\r\n    * @param {number} limit - Limit number of Professionals to be returned.\r\n    * @returns {Promise<Professional[]>}\r\n    */\r\n    list({ skip = 0, limit = 50 } = {}) {\r\n        return this.find()\r\n        .sort({ createdAt: -1 })\r\n        .skip(skip)\r\n        .limit(limit)\r\n        .exec();\r\n    }\r\n};\r\n\r\n\r\nexport default mongoose.model('Professional', ProfessionalSchema);\r\n"]}