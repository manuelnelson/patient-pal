{"version":3,"sources":["../../src/server/models/professional.js"],"names":["ProfessionalSchema","Schema","email","type","String","required","validate","isEmail","unique","firstname","lastname","clients","ObjectId","ref","status","Boolean","createdAt","Date","default","now","statics","get","id","findById","populate","exec","then","Professional","err","NOT_FOUND","reject","getByEmail","findOne","list","skip","limit","find","sort","model"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAMA,qBAAqB,IAAI,mBAASC,MAAb,CAAoB;AAC3CC,WAAM;AACFC,cAAMC,MADJ;AAEFC,kBAAU,IAFR;AAGFC,kBAAU,CAAE,oBAAUC,OAAZ,EAAqB,eAArB,CAHR;AAIFC,gBAAQ;AAJN,KADqC;AAO3CC,eAAW;AACPN,cAAMC;AADC,KAPgC;AAU3CM,cAAU;AACNP,cAAMC;AADA,KAViC;AAa3CO,cAAS,CAAC,EAACR,MAAK,mBAASF,MAAT,CAAgBW,QAAtB,EAA+BC,KAAI,SAAnC,EAAD,CAbkC;AAc3C;AACAC,YAAQ;AACJX,cAAMY;AADF,KAfmC;AAkB3CC,eAAW;AACPb,cAAMc,IADC;AAEPC,iBAASD,KAAKE;AAFP;AAlBgC,CAApB,CAA3B;;AAwBA;;;AAGAnB,mBAAmBoB,OAAnB,GAA6B;AACzB;;;;;AAKAC,OANyB,eAMrBC,EANqB,EAMjB;AACJ,eAAO,KAAKC,QAAL,CAAcD,EAAd,EACNE,QADM,CACG,UADH,EAENC,IAFM,GAGNC,IAHM,CAGD,UAACC,YAAD,EAAkB;AACpB,gBAAIA,YAAJ,EAAkB;AACd,uBAAOA,YAAP;AACH;AACD,gBAAMC,MAAM,uBAAa,8BAAb,EAA6C,qBAAWC,SAAxD,CAAZ;AACA,mBAAO,mBAAQC,MAAR,CAAeF,GAAf,CAAP;AACH,SATM,CAAP;AAUH,KAjBwB;;AAkBzB;;;;;AAKAG,cAvByB,sBAuBd7B,KAvBc,EAuBP;AACd,eAAO,KAAK8B,OAAL,CAAa,EAAC9B,OAAMA,KAAP,EAAb,EACNsB,QADM,CACG,UADH,EAENC,IAFM,GAECC,IAFD,CAEM,UAACC,YAAD,EAAkB;AAC3B,gBAAIA,YAAJ,EAAkB;AACd,uBAAOA,YAAP;AACH;AACD,gBAAMC,MAAM,uBAAa,8BAAb,EAA6C,qBAAWC,SAAxD,CAAZ;AACA,mBAAO,mBAAQC,MAAR,CAAeF,GAAf,CAAP;AACH,SARM,CAAP;AASH,KAjCwB;;;AAmCzB;;;;;;AAMAK,QAzCyB,kBAyCW;AAAA,uFAAJ,EAAI;AAAA,6BAA7BC,IAA6B;AAAA,YAA7BA,IAA6B,6BAAtB,CAAsB;AAAA,8BAAnBC,KAAmB;AAAA,YAAnBA,KAAmB,8BAAX,EAAW;;AAChC,eAAO,KAAKC,IAAL,GACNC,IADM,CACD,EAAErB,WAAW,CAAC,CAAd,EADC,EAENkB,IAFM,CAEDA,IAFC,EAGNC,KAHM,CAGAA,KAHA,EAINV,IAJM,EAAP;AAKH;AA/CwB,CAA7B;;kBAmDe,mBAASa,KAAT,CAAe,cAAf,EAA+BtC,kBAA/B,C","file":"professional.js","sourcesContent":["import Promise from 'bluebird';\r\nimport mongoose from 'mongoose';\r\nimport httpStatus from 'http-status';\r\nimport APIError from '../lib/APIError';\r\nimport validator from 'validator';\r\nimport bcrypt from 'bcrypt-nodejs';\r\n\r\nconst ProfessionalSchema = new mongoose.Schema({\r\n    email:{\r\n        type: String,\r\n        required: true,\r\n        validate: [ validator.isEmail, 'invalid email' ],\r\n        unique: true\r\n    },\r\n    firstname: {\r\n        type: String,\r\n    },\r\n    lastname: {\r\n        type: String,\r\n    },\r\n    clients:[{type:mongoose.Schema.ObjectId,ref:'Client'}],\r\n    //1 = active, 0 = disabled or disactive\r\n    status: {\r\n        type: Boolean\r\n    },\r\n    createdAt: {\r\n        type: Date,\r\n        default: Date.now\r\n    }\r\n});\r\n\r\n/**\r\n* Statics\r\n*/\r\nProfessionalSchema.statics = {\r\n    /**\r\n    * Get Professional\r\n    * @param {ObjectId} email - The email of Professional.\r\n    * @returns {Promise<Professional, APIError>}\r\n    */\r\n    get(id) {\r\n        return this.findById(id)\r\n        .populate('clients')\r\n        .exec()\r\n        .then((Professional) => {\r\n            if (Professional) {\r\n                return Professional;\r\n            }\r\n            const err = new APIError('No such Professional exists!', httpStatus.NOT_FOUND);\r\n            return Promise.reject(err);\r\n        });\r\n    },\r\n    /**\r\n    * Get Professional by Email\r\n    * @param {string} email - The email of Professional.\r\n    * @returns {Promise<Professional, APIError>}\r\n    */\r\n    getByEmail(email) {\r\n        return this.findOne({email:email})\r\n        .populate('clients')\r\n        .exec().then((Professional) => {\r\n            if (Professional) {\r\n                return Professional;\r\n            }\r\n            const err = new APIError('No such Professional exists!', httpStatus.NOT_FOUND);\r\n            return Promise.reject(err);\r\n        });\r\n    },\r\n\r\n    /**\r\n    * List Professionals in descending order of 'createdAt' timestamp.\r\n    * @param {number} skip - Number of Professionals to be skipped.\r\n    * @param {number} limit - Limit number of Professionals to be returned.\r\n    * @returns {Promise<Professional[]>}\r\n    */\r\n    list({ skip = 0, limit = 50 } = {}) {\r\n        return this.find()\r\n        .sort({ createdAt: -1 })\r\n        .skip(skip)\r\n        .limit(limit)\r\n        .exec();\r\n    }\r\n};\r\n\r\n\r\nexport default mongoose.model('Professional', ProfessionalSchema);\r\n"]}