{"version":3,"sources":["../../src/server/models/client.js"],"names":["ClientSchema","Schema","email","type","String","required","validate","isEmail","unique","firstname","lastname","birth","Date","sex","professional","ObjectId","ref","organization","insurance","status","Boolean","createdAt","default","now","statics","get","id","findById","populate","exec","then","Client","err","NOT_FOUND","reject","getByEmail","findOne","exists","list","skip","limit","find","sort","model"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAMA,eAAe,IAAI,mBAASC,MAAb,CAAoB;AACrCC,WAAM;AACFC,cAAMC,MADJ;AAEFC,kBAAU,IAFR;AAGFC,kBAAU,CAAE,oBAAUC,OAAZ,EAAqB,eAArB,CAHR;AAIFC,gBAAQ;AAJN,KAD+B;AAOrCC,eAAW;AACPN,cAAMC;AADC,KAP0B;AAUrCM,cAAU;AACNP,cAAMC;AADA,KAV2B;AAarCO,WAAO;AACHR,cAAMS;AADH,KAb8B;AAgBrCC,SAAK;AACDV,cAAMC;AADL,KAhBgC;AAmBrCU,kBAAc;AACVX,cAAM,mBAASF,MAAT,CAAgBc,QADZ;AAEVC,aAAK;AAFK,KAnBuB;AAuBrCC,kBAAc;AACVd,cAAM,mBAASF,MAAT,CAAgBc,QADZ;AAEVC,aAAK;AAFK,KAvBuB;AA2BrCE,eAAW;AACPf,cAAMC;AADC,KA3B0B;AA8BrC;AACAe,YAAQ;AACJhB,cAAMiB;AADF,KA/B6B;AAkCrCC,eAAW;AACPlB,cAAMS,IADC;AAEPU,iBAASV,KAAKW;AAFP;AAlC0B,CAApB,CAArB;;AAwCA;;;AAGAvB,aAAawB,OAAb,GAAuB;AACnB;;;;;AAKAC,OANmB,eAMfC,EANe,EAMX;AACJ,eAAO,KAAKC,QAAL,CAAcD,EAAd,EACNE,QADM,CACG,cADH,EAENC,IAFM,GAGNC,IAHM,CAGD,UAACC,MAAD,EAAY;AACd,gBAAIA,MAAJ,EAAY;AACR,uBAAOA,MAAP;AACH,aAFD,MAGI;AACA,oBAAMC,MAAM,uBAAa,wBAAb,EAAuC,qBAAWC,SAAlD,CAAZ;AACA,uBAAO,mBAAQC,MAAR,CAAeF,GAAf,CAAP;AACH;AACJ,SAXM,CAAP;AAYH,KAnBkB;;AAoBnB;;;;;AAKAG,cAzBmB,sBAyBRjC,KAzBQ,EAyBD;AACd,eAAO,KAAKkC,OAAL,CAAa,EAAClC,OAAMA,KAAP,EAAb,EAA4B2B,IAA5B,GAAmCC,IAAnC,CAAwC,UAACC,MAAD,EAAY;AACvD,gBAAIA,MAAJ,EAAY;AACR,uBAAOA,MAAP;AACH,aAFD,MAGI;AACA,oBAAMC,MAAM,uBAAa,wBAAb,EAAuC,qBAAWC,SAAlD,CAAZ;AACA,uBAAO,mBAAQC,MAAR,CAAeF,GAAf,CAAP;AACH;AACJ,SARM,CAAP;AASH,KAnCkB;;;AAqCf;;;;;AAKJK,UA1CmB,kBA0CZnC,KA1CY,EA0CL;AACV,eAAO,KAAKkC,OAAL,CAAa,EAAClC,OAAMA,KAAP,EAAb,EACN2B,IADM,GACCC,IADD,CACM,UAACC,MAAD,EAAY;AACrB,gBAAIA,MAAJ,EAAY;AACR,uBAAOA,MAAP;AACH;AACD,mBAAO,IAAP;AACH,SANM,CAAP;AAOH,KAlDkB;;;AAqDnB;;;;;;AAMAO,QA3DmB,kBA2DiB;AAAA,uFAAJ,EAAI;AAAA,6BAA7BC,IAA6B;AAAA,YAA7BA,IAA6B,6BAAtB,CAAsB;AAAA,8BAAnBC,KAAmB;AAAA,YAAnBA,KAAmB,8BAAX,EAAW;;AAChC,eAAO,KAAKC,IAAL,GACNC,IADM,CACD,EAAErB,WAAW,CAAC,CAAd,EADC,EAENkB,IAFM,CAEDA,IAFC,EAGNC,KAHM,CAGAA,KAHA,EAINX,IAJM,EAAP;AAKH;AAjEkB,CAAvB;;kBAqEe,mBAASc,KAAT,CAAe,QAAf,EAAyB3C,YAAzB,C","file":"client.js","sourcesContent":["import Promise from 'bluebird';\r\nimport mongoose from 'mongoose';\r\nimport httpStatus from 'http-status';\r\nimport APIError from '../lib/APIError';\r\nimport validator from 'validator';\r\nimport bcrypt from 'bcrypt-nodejs';\r\n\r\nconst ClientSchema = new mongoose.Schema({\r\n    email:{\r\n        type: String,\r\n        required: true,\r\n        validate: [ validator.isEmail, 'invalid email' ],\r\n        unique: true\r\n    },\r\n    firstname: {\r\n        type: String,\r\n    },\r\n    lastname: {\r\n        type: String,\r\n    },\r\n    birth: {\r\n        type: Date\r\n    },\r\n    sex: {\r\n        type: String\r\n    },\r\n    professional: {\r\n        type: mongoose.Schema.ObjectId,\r\n        ref: 'Professional'\r\n    },\r\n    organization: {\r\n        type: mongoose.Schema.ObjectId,\r\n        ref: 'Organization'\r\n    },\r\n    insurance: {\r\n        type: String\r\n    },\r\n    //1 = active, 0 = disabled or disactive\r\n    status: {\r\n        type: Boolean\r\n    },\r\n    createdAt: {\r\n        type: Date,\r\n        default: Date.now\r\n    }\r\n});\r\n\r\n/**\r\n* Statics\r\n*/\r\nClientSchema.statics = {\r\n    /**\r\n    * Get Client\r\n    * @param {ObjectId} id - The objectId of Client.\r\n    * @returns {Promise<Client, APIError>}\r\n    */\r\n    get(id) {\r\n        return this.findById(id)\r\n        .populate('professional')\r\n        .exec()\r\n        .then((Client) => {\r\n            if (Client) {\r\n                return Client;\r\n            }\r\n            else{\r\n                const err = new APIError('No such Client exists!', httpStatus.NOT_FOUND);\r\n                return Promise.reject(err);\r\n            }\r\n        });\r\n    },\r\n    /**\r\n    * Get Client by Email\r\n    * @param {string} email - The email of Client.\r\n    * @returns {Promise<Client, APIError>}\r\n    */\r\n    getByEmail(email) {\r\n        return this.findOne({email:email}).exec().then((Client) => {\r\n            if (Client) {\r\n                return Client;\r\n            }\r\n            else{\r\n                const err = new APIError('No such Client exists!', httpStatus.NOT_FOUND);\r\n                return Promise.reject(err);\r\n            }\r\n        });\r\n    },\r\n\r\n        /**\r\n    * Get Professional by Email\r\n    * @param {string} email - The email of Professional.\r\n    * @returns {Promise<Professional, APIError>}\r\n    */\r\n    exists(email) {\r\n        return this.findOne({email:email})\r\n        .exec().then((Client) => {\r\n            if (Client) {\r\n                return Client;\r\n            }\r\n            return null;\r\n        });\r\n    },\r\n\r\n\r\n    /**\r\n    * List Clients in descending order of 'createdAt' timestamp.\r\n    * @param {number} skip - Number of Clients to be skipped.\r\n    * @param {number} limit - Limit number of Clients to be returned.\r\n    * @returns {Promise<Client[]>}\r\n    */\r\n    list({ skip = 0, limit = 50 } = {}) {\r\n        return this.find()\r\n        .sort({ createdAt: -1 })\r\n        .skip(skip)\r\n        .limit(limit)\r\n        .exec();\r\n    }\r\n};\r\n\r\n\r\nexport default mongoose.model('Client', ClientSchema);\r\n"]}