{"version":3,"sources":["../../src/server/models/user.js"],"names":["UserSchema","Schema","email","type","String","required","validate","isEmail","unique","password","select","role","Number","client","ObjectId","ref","professional","createdAt","Date","default","now","pre","next","that","get","then","prof","remove","_id","catch","e","user","isModified","genSalt","err","salt","hash","hashedPassword","methods","comparePassword","candidatePassword","compare","isMatch","statics","id","findById","populate","exec","getByEmail","includePassword","query","findOne","list","skip","limit","find","sort","model"],"mappings":"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","file":"user.js","sourcesContent":["import Promise from 'bluebird';\r\nimport mongoose from 'mongoose';\r\nimport httpStatus from 'http-status';\r\nimport APIError from '../lib/APIError';\r\nimport validator from 'validator';\r\nimport bcrypt from 'bcrypt-nodejs';\r\nimport Client from './client';\r\nimport Professional from './professional';\r\nconst UserSchema = new mongoose.Schema({\r\n    email: {\r\n        type: String,\r\n        required: true,\r\n        validate: [ validator.isEmail, 'invalid email' ],\r\n        unique: true\r\n    },\r\n    password: {\r\n        type: String,\r\n        required: true,\r\n        select: false\r\n        // match: /(?=.*[a-zA-Z])(?=.*[0-9]+).*/,\r\n        // minlength:\r\n    },\r\n    //admin = 1, office/health professional = 2, client = 10 (gaps added in case we add more)\r\n    role: {\r\n        type: Number,\r\n        required: true\r\n    },\r\n    client: {\r\n        type: mongoose.Schema.ObjectId,\r\n        ref: 'Client'\r\n    },\r\n    professional: {\r\n        type: mongoose.Schema.ObjectId,\r\n        ref: 'Professional'\r\n    },\r\n    createdAt: {\r\n        type: Date,\r\n        default: Date.now\r\n    }\r\n});\r\n\r\n//Delete hooks - will remove associated entities \r\nUserSchema.pre('remove', function(next) {\r\n    var that = this;\r\n    if(that.professional){\r\n        return Professional.get(that.professional)        \r\n        .then((prof) => {\r\n            prof.remove(prof._id);\r\n            return next();            \r\n        })\r\n        .catch(e => next(e));\r\n    }\r\n    if(that.client){\r\n        return Client.get(that.client)        \r\n        .then((client) => {\r\n            client.remove(client._id);\r\n            return next();            \r\n        })\r\n        .catch(e => next(e));\r\n    }\r\n    return next();\r\n});\r\n\r\n\r\n/* the callback function (2nd parameter below) accepts a parameter which we\r\nare calling \"next\". This is ALSO a callback function that needs to be executed\r\nwhen we would like to move on from this pre-save hook. If we do not invoke the\r\n\"next\" function, our server will hang. */\r\nUserSchema.pre('save', function(next){\r\n    // we do not want to lose the correct context of the keyword `this`, so let's cache it in a variable called user\r\n    var user = this;\r\n    /* if the user's password has not been modified, do not continue with\r\n    hashing their password....this is for updating a user. If a user does not\r\n    update their password, do not create a new password hash! */\r\n    if (!user.isModified('password')) return next();\r\n\r\n    bcrypt.genSalt(10, function(err,salt){\r\n        // if the user has modified their password, let's hash it\r\n        bcrypt.hash(user.password, salt, function(){},function(err,hashedPassword) {\r\n            if(err){next(err);}\r\n            // then let's set their password to not be the plain text one anymore, but the newly hashed password\r\n            user.password = hashedPassword;\r\n            // then we save the user in the db!\r\n            next();\r\n        }, function(err){\r\n            // or we continue and pass in an error that has happened (which our express error handler will catch)\r\n            return next(err);\r\n        })\r\n\r\n    })\r\n});\r\n\r\n/* now let's write an instance method for all of our user documents which\r\nwill  be used to compare a plain text password with a hashed password\r\nin the database.  */\r\nUserSchema.methods.comparePassword = function(candidatePassword, next) {\r\n    // when this method is called, compare the plain text password with the password in the database.\r\n    bcrypt.compare(candidatePassword, this.password, function(err, isMatch) {\r\n        if(err) return next(err);\r\n        // isMatch is a boolean which we will pass to our next function\r\n        next(null, isMatch);\r\n    });\r\n};\r\n\r\n/**\r\n* Statics\r\n*/\r\nUserSchema.statics = {\r\n    /**\r\n    * Get user\r\n    * @param {ObjectId} id - The objectId of user.\r\n    * @returns {Promise<User, APIError>}\r\n    */\r\n    get(id) {\r\n        return this.findById(id)\r\n        .populate('professional client')\r\n        .exec()\r\n        .then((user) => {\r\n            if (user) {\r\n                return user;\r\n            }\r\n            return null;\r\n            // const err = new APIError('No such user exists!', httpStatus.NOT_FOUND);\r\n            // return Promise.reject(err);\r\n        });\r\n    },\r\n    /**\r\n    * Get user by Email\r\n    * @param {string} email - The email of user.\r\n    * @param {boolean} includePassword - Whether or not to include .\r\n    * @returns {Promise<User, APIError>}\r\n    */\r\n    getByEmail(email, includePassword) {\r\n        var query = this.findOne({email:email});\r\n        if(includePassword)\r\n            query = query.select('+password');\r\n        query = query.populate('professional client')\r\n        return query.exec().then((user) => {\r\n            if (user) {\r\n                return user;\r\n            }\r\n            return null;\r\n            // const err = new APIError('No such user exists!', httpStatus.NOT_FOUND);\r\n            // return Promise.reject(err);\r\n        });\r\n    },\r\n\r\n    /**\r\n    * List users in descending order of 'createdAt' timestamp.\r\n    * @param {number} skip - Number of users to be skipped.\r\n    * @param {number} limit - Limit number of users to be returned.\r\n    * @returns {Promise<User[]>}\r\n    */\r\n    list({ skip = 0, limit = 50 } = {}) {\r\n        return this.find()\r\n        .sort({ createdAt: -1 })\r\n        .skip(skip)\r\n        .limit(limit)\r\n        .exec();\r\n    }\r\n};\r\n\r\n\r\nexport default mongoose.model('User', UserSchema);\r\n"]}