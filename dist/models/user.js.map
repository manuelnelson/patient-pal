{"version":3,"sources":["../../src/server/models/user.js"],"names":["UserSchema","Schema","email","type","String","required","validate","isEmail","unique","password","select","role","Number","patient","ObjectId","ref","professional","createdAt","Date","default","now","pre","next","user","isModified","genSalt","err","salt","hash","hashedPassword","methods","comparePassword","candidatePassword","compare","isMatch","statics","get","id","findById","exec","then","getByEmail","includePassword","query","findOne","list","skip","limit","find","sort","model"],"mappings":"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","file":"user.js","sourcesContent":["import Promise from 'bluebird';\r\nimport mongoose from 'mongoose';\r\nimport httpStatus from 'http-status';\r\nimport APIError from '../lib/APIError';\r\nimport validator from 'validator';\r\nimport bcrypt from 'bcrypt-nodejs';\r\nimport Patient from './patient';\r\nimport Professional from './professional';\r\nconst UserSchema = new mongoose.Schema({\r\n    email: {\r\n        type: String,\r\n        required: true,\r\n        validate: [ validator.isEmail, 'invalid email' ],\r\n        unique: true\r\n    },\r\n    password: {\r\n        type: String,\r\n        required: true,\r\n        select: false\r\n        // match: /(?=.*[a-zA-Z])(?=.*[0-9]+).*/,\r\n        // minlength:\r\n    },\r\n    //admin = 1, office/health professional = 2, patient = 10 (gaps added in case we add more)\r\n    role: {\r\n        type: Number,\r\n        required: true\r\n    },\r\n    patient: {\r\n        type: mongoose.Schema.ObjectId,\r\n        ref: 'Patient'\r\n    },\r\n    professional: {\r\n        type: mongoose.Schema.ObjectId,\r\n        ref: 'Professional'\r\n    },\r\n    createdAt: {\r\n        type: Date,\r\n        default: Date.now\r\n    }\r\n});\r\n\r\n/* the callback function (2nd parameter below) accepts a parameter which we\r\nare calling \"next\". This is ALSO a callback function that needs to be executed\r\nwhen we would like to move on from this pre-save hook. If we do not invoke the\r\n\"next\" function, our server will hang. */\r\nUserSchema.pre('save', function(next){\r\n    // we do not want to lose the correct context of the keyword `this`, so let's cache it in a variable called user\r\n    var user = this;\r\n    /* if the user's password has not been modified, do not continue with\r\n    hashing their password....this is for updating a user. If a user does not\r\n    update their password, do not create a new password hash! */\r\n    if (!user.isModified('password')) return next();\r\n\r\n    bcrypt.genSalt(10, function(err,salt){\r\n        // if the user has modified their password, let's hash it\r\n        bcrypt.hash(user.password, salt, function(){},function(err,hashedPassword) {\r\n            if(err){next(err);}\r\n            // then let's set their password to not be the plain text one anymore, but the newly hashed password\r\n            user.password = hashedPassword;\r\n            // then we save the user in the db!\r\n            next();\r\n        }, function(err){\r\n            // or we continue and pass in an error that has happened (which our express error handler will catch)\r\n            return next(err);\r\n        })\r\n\r\n    })\r\n});\r\n\r\n/* now let's write an instance method for all of our user documents which\r\nwill  be used to compare a plain text password with a hashed password\r\nin the database.  */\r\nUserSchema.methods.comparePassword = function(candidatePassword, next) {\r\n    // when this method is called, compare the plain text password with the password in the database.\r\n    bcrypt.compare(candidatePassword, this.password, function(err, isMatch) {\r\n        if(err) return next(err);\r\n        // isMatch is a boolean which we will pass to our next function\r\n        next(null, isMatch);\r\n    });\r\n};\r\n\r\n/**\r\n* Statics\r\n*/\r\nUserSchema.statics = {\r\n    /**\r\n    * Get user\r\n    * @param {ObjectId} id - The objectId of user.\r\n    * @returns {Promise<User, APIError>}\r\n    */\r\n    get(id) {\r\n        return this.findById(id)\r\n        .exec()\r\n        .then((user) => {\r\n            if (user) {\r\n                return user;\r\n            }\r\n            return null;\r\n            // const err = new APIError('No such user exists!', httpStatus.NOT_FOUND);\r\n            // return Promise.reject(err);\r\n        });\r\n    },\r\n    /**\r\n    * Get user by Email\r\n    * @param {string} email - The email of user.\r\n    * @param {boolean} includePassword - Whether or not to include .\r\n    * @returns {Promise<User, APIError>}\r\n    */\r\n    getByEmail(email, includePassword) {\r\n        var query = this.findOne({email:email});\r\n        if(includePassword)\r\n            query = query.select('+password');\r\n        return query.exec().then((user) => {\r\n            if (user) {\r\n                return user;\r\n            }\r\n            return null;\r\n            // const err = new APIError('No such user exists!', httpStatus.NOT_FOUND);\r\n            // return Promise.reject(err);\r\n        });\r\n    },\r\n\r\n    /**\r\n    * List users in descending order of 'createdAt' timestamp.\r\n    * @param {number} skip - Number of users to be skipped.\r\n    * @param {number} limit - Limit number of users to be returned.\r\n    * @returns {Promise<User[]>}\r\n    */\r\n    list({ skip = 0, limit = 50 } = {}) {\r\n        return this.find()\r\n        .sort({ createdAt: -1 })\r\n        .skip(skip)\r\n        .limit(limit)\r\n        .exec();\r\n    }\r\n};\r\n\r\n\r\nexport default mongoose.model('User', UserSchema);\r\n"]}